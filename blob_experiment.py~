'''
Very basic command-line interface for determining the validity of the dependent blob detection programs on the given dataset

Copyright (c) 2015, Laura Eckman

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
'''

import skimage
from skimage import data
from img_array.bloblog_2MASS import blobl
from img_array.blobdoh_2MASS import blobh
from img_array.blobdog_2MASS import blobg
from img_array.diffraction import diffract
from img_array.thresholding import threshold as thresh
from img_array.array_processing import lingray, loggray
from matplotlib import pyplot as plt
import os
import pyfits
import numpy as np
import time
from math import floor

image_list = []

for i in range(530,540):
    dir = 'RandSample/FITS/index-'+str(i)
    files = [f for f in os.walk(dir)]
    for f in files[0][2]:
        if 'stellar' not in f and ('2MASS' in f): #byproduct of my directory and pre-processing
            image_list.append(dir+'/'+f)

arrays = dict.fromkeys(image_list)

for i in image_list:
    inhdulist = pyfits.open(i)
    image_data = inhdulist[0].data
    lin_image_data = lingray(image_data)
    log_image_data = loggray(image_data)
    arrays[i]=(lin_image_data,log_image_data)
    inhdulist.close()

lin_error = 0
log_error = 0

for array in arrays:
    i = arrays[array]
    if i==None:
        continue
    '''
    lin = i[0]
    if np.isnan(lin).any():
        continue
    log = blobl(lin)
    dog = blobg(lin)
    doh = blobh(lin)

    plt.title(array+" LINEAR TRANSFORM")
    plt.draw()
    plt.pause(.2)
    lin_error += int(raw_input("Enter to continue: "))-1
    plt.close()
    '''

    lig = i[1]
    if np.isnan(lig).any():
        continue
    #thresh_val = thresh(lig)[1]
    #dif = diffract(lig)
    log2 = blobl(lig)
    #dog2 = blobg(lig)
    #doh2 = blobh(lig)
    plt.title(array+" LOG TRANSFORM")
    plt.draw()
    plt.pause(.2)
    log_error += int(raw_input("Enter to continue: "))-1
    plt.close()


print 'Linear Error:',float(lin_error)/len(arrays)
print 'Log Error:',float(log_error)/len(arrays)

### W4 BAND USE SPECIFICATIONS ###
'''
Indices range (0,20)
Linear Error: 0.45
Log Error: 0.25
Thresholded Linear Error: 0.6
Thresholded Log Error: 0.75

Indices range (20,40)
Linear Error: 0.65
Log Error: 0.15
Thresholded Linear Error: 0.8
Thresholded Log Error: 0.75

Indices range(40,60)
Linear Error: 0.7
Log Error: 0.1
Thresholded Linear Error: 0.85
Thresholded Log Error: 0.9

For w4 bands, loggray is the most effective transform
Bad w4 bands are almost exclusively over .5 whiteness in thresholded version - good metric to throw things out 
'''
### W3 BAND USE SPECIFICATIONS ###
'''
Indices range (0,20)
Linear Error: 0.0
Log Error: 0.0
Thresholded Linear Error: 0.1
Thresholded Log Error: 0.1

ALL BANDS W1-W3
Indices range(20,25)
Linear Error: 0.0
Log Error: 0.0
Thresholded Linear Error: 0.0666666666667
Thresholded Log Error: 0.0666666666667

For bands w1-w3, any preprocessing does not detract from blob detectability
Errors in threshold stemmed from weird, w4-like bad target images in w3 bands - could add similar .5 metric to rule these out

STATS RECONFIRM .5 METRIC - AVERAGE THRESHOLD VALUES
    GOOD LIST
    0.3447265625
    0.345703125
    0.35390625

    MID LIST
    0.453125
    0.380859375
    0.431640625

    BAD LIST
    0.613671875
    0.611979166667
    0.548828125

***threshold VALUE (returned from threshold()) over .5 equally as bad a warning sign as over half of binary image true***

BLOBDOG ERROR:
Log Error: 0.241666666667 (range(40))
Log Error: 0.108333333333 (range(100,140))
^^ not bad, but could be improved

BLOBLOB ERROR:
Log Error: 0.15 (range(40))
Log Error: 0.108333333333 (range(100,140)
^^ immediately looks to track the proper size of things better
'''
### 2MASS SPECS ###
'''
Lin/Log seem to be equally good, but log seems to result in higher quality image processing >>> continuing with log processing for 2MASS images

some NaN image errors have arisen, np.isnan() is currently checking for/fixing those

blobdoh_2MASS.py works exceptionally well (always accurate except for imaging NaN, central black from overflow errors)
'''


